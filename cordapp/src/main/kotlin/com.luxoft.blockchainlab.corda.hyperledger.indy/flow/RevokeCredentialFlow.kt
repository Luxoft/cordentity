package com.luxoft.blockchainlab.corda.hyperledger.indy.flow

import co.paralleluniverse.fibers.Suspendable
import com.luxoft.blockchainlab.corda.hyperledger.indy.contract.IndyCredentialContract
import com.luxoft.blockchainlab.corda.hyperledger.indy.data.state.IndyCredential
import com.luxoft.blockchainlab.hyperledger.indy.getRevocationRegistryId
import net.corda.core.contracts.Command
import net.corda.core.contracts.StateAndRef
import net.corda.core.flows.*
import net.corda.core.transactions.TransactionBuilder


/**
 * Flow to revoke previously issued credential
 */
object RevokeCredentialFlow {

    /**
     * @param credentialStateIn           credential generated by [IssueCredentialFlow]
     */
    @InitiatingFlow
    @StartableByRPC
    open class Issuer(private val credentialStateIn: StateAndRef<IndyCredential>) : FlowLogic<Unit>() {

        @Suspendable
        override fun call() {
            try {
                val credential = credentialStateIn.state.data

                val revRegId = credential.credentialInfo.credential.getRevocationRegistryId()!!
                val credRevId = credential.credentialInfo.credRevocId!!

                // revoke that credential
                indyUser().revokeCredential(revRegId, credRevId)

                val commandType = IndyCredentialContract.Command.Revoke()
                val signers = listOf(ourIdentity.owningKey)
                val command = Command(commandType, signers)

                val trxBuilder = TransactionBuilder(whoIsNotary())
                    .withItems(credentialStateIn, command)

                trxBuilder.toWireTransaction(serviceHub)
                    .toLedgerTransaction(serviceHub)
                    .verify()

                val selfSignedTx = serviceHub.signInitialTransaction(trxBuilder, ourIdentity.owningKey)

                subFlow(FinalityFlow(selfSignedTx))

            } catch (ex: Exception) {
                logger.error("", ex)
                throw FlowException(ex.message)
            }
        }
    }
}